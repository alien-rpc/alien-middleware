# alien-middleware

Reusable middleware chains with top-notch TypeScript support. Built upon [Hattip](https://github.com/hattipjs/hattip) to avoid vendor lock-in using Web Standard APIs.

## Philosophy

By default, middlewares in `alien-middleware` are **synchronous** or **promise-based**. There is no `next()` function to call. If a middleware returns a `Response`, the chain is terminated. If a middleware wants to extend the request context, it returns an object implementing the `RequestPlugin` interface.

Middlewares are either **request-oriented** (the default) or **response-oriented**. Response-oriented middlewares run _after_ a `Response` has been generated. They're allowed to return a new `Response`, but cannot return a `RequestPlugin` object.

## Quick Start

First, add the package to your project:

```bash
pnpm add alien-middleware
```

### Creating a Chain

Import the `chain` function and initialize a middleware chain. You can optionally provide an initial middleware directly to `chain`.

```typescript
import { chain } from 'alien-middleware'

// Create an empty chain
const app = chain()

// Or create a chain with an initial middleware
const appWithInitial = chain(context => {
  console.log('Initial middleware running for:', context.request.url)
})
```

### Adding Middleware with `.use()`

Use the `.use()` method to add middleware functions to the chain. Each call to `.use()` returns a _new_, immutable chain instance.

```typescript
import type { RequestContext } from 'alien-middleware'

const firstMiddleware = (context: RequestContext) => {
  console.log('First middleware')
  // Doesn't return anything, so the chain continues
}

const secondMiddleware = (context: RequestContext) => {
  console.log('Second middleware')
  return new Response('Hello from middleware!', { status: 200 })
  // Returns a Response, terminating the request-phase chain
}

// Add middleware sequentially
const app = chain().use(firstMiddleware).use(secondMiddleware)
```

> [!NOTE]
> Middleware chains are immutable. Each call to `.use()` returns a new chain instance.

### Executing the Chain

To run the middleware chain, pass it to a Hattip adapter like the [Node adapter](https://www.npmjs.com/package/@hattip/adapter-node). The middleware chain is a valid Hattip handler.

```typescript
import { createServer } from '@hattip/adapter-node'

const app = chain()
  .use(mySessionMiddleware)
  .use(myAuthMiddleware)
  .use(myLoggerMiddleware)

// Create a server
const server = createServer(app)

// Start the server
server.listen(3000, () => {
  console.log('Server is running on port 3000')
})
```

> [!NOTE]
> If no middleware in the chain returns a `Response`, a `404 Not Found` response
> is automatically returned.

### Request Middleware

Request middleware runs sequentially before a `Response` is generated.

- **Terminating the Chain:** Return a `Response` object to stop processing subsequent request middleware.

  ```typescript
  const earlyResponder = (context: RequestContext) => {
    if (context.request.url.endsWith('/forbidden')) {
      return new Response('Forbidden', { status: 403 })
    }
    // Otherwise, continue the chain
  }
  ```

- **Extending Context:** Return an object with a `define` property to add properties to the context for _downstream_ middleware.

  ```typescript
  const addUser = (context: RequestContext) => {
    // In a real app, you might look up a user based on a token
    const user = { id: 1, name: 'Alice' }

    return { define: { user } }
  }

  const greetUser = (
    context: RequestContext<{ user: { id: number; name: string } }>
  ) => {
    // The `user` property is now available thanks to `addUser`
    return new Response(`Hello, ${context.user.name}!`)
  }

  const app = chain().use(addUser).use(greetUser)
  ```

- **Extending Environment:** Return an object with an `env` property to add environment variables accessible via `context.env()`.

  ```typescript
  const addApiKey = (context: RequestContext) => {
    return { env: { API_KEY: 'secret123' } }
  }

  const useApiKey = (context: RequestContext<{}, { API_KEY: string }>) => {
    const key = context.env('API_KEY')
    console.log('API Key:', key) // Output: API Key: secret123
  }

  const app = chain().use(addApiKey).use(useApiKey)
  ```

> [!NOTE]
> If you're wondering why you need to return a `{ define: { … } }` object
> (rather than simply assigning to the context object), it's because TypeScript
> is unable to infer the type of the context object downstream if you don't do
> it like this.
>
> Another thing to note is you don't typically define middlewares outside the
> `.use(…)` call expression, since that requires you to unnecessarily declare
> the type of the context object. It's better to define them inline.

### Response Middleware

Response middleware runs _after_ a `Response` has been generated by a request middleware or the final handler. It receives both the context and the generated `Response`.

```typescript
const poweredByMiddleware = (context: RequestContext, response: Response) => {
  response.headers.set('X-Powered-By', 'alien-middleware')
}

const mainHandler = (context: RequestContext) => {
  return new Response('Main content')
}

// `poweredByMiddleware` runs after `mainHandler` generates a response
const app = chain().use(mainHandler).use(poweredByMiddleware)

const response = await app({…})
console.log(response.headers.get('X-Powered-By')) // Output: alien-middleware
```

> [!NOTE]
> Response middleware cannot extend the context using `{ define }` or `{ env }`.
> They can only inspect the `Response` or replace it by returning a new
> `Response`.

Your response middlewares will run even if no `Response` is generated by the
request middlewares, **except** when the middleware chain is nested inside
another chain, since the outer chain will still have a chance to return a
`Response`.

### Nesting Chains

You can compose middleware by nesting chains using `.use()`. Context modifications (`define`, `env`) within a nested chain are scoped to that chain and do not affect middleware outside of it.

```typescript
const innerChain = chain((context: RequestContext) => {
  console.log('Inner chain start')
  return { define: { innerData: 'secret' } } // Only available inside innerChain
}).use((context: RequestContext<{ innerData: string }>) => {
  console.log('Accessing inner data:', context.innerData)
})

const outerMiddleware = (context: RequestContext) => {
  // context.innerData is not accessible here
  console.log('Outer middleware after inner chain')
  if (!('innerData' in context)) {
    console.log('innerData is correctly scoped.')
  }
  return new Response('Finished')
}

const finalApp = chain().use(innerChain).use(outerMiddleware)
// Output when executing the finalApp chain:
//   Inner chain start
//   Accessing inner data: secret
//   Outer middleware after inner chain
//   innerData is correctly scoped.
```

If a nested chain does not return a `Response`, execution continues with the next middleware in the outer chain.

### Safe Environment Variables

When writing a Hattip handler without this package, the `context.env()` method is inherently unsafe. Its return type is always `string | undefined`, which means you either need to write defensive checks or use type assertions. Neither is ideal.

With alien-middleware, you **must** declare an environment variable's type in order to use it.

```typescript
import { chain } from 'alien-middleware'

// A common pattern is to declare a dedicated type for the environment variables.
type Env = {
  API_KEY: string
}

const app = chain<any, Env>().use(context => {
  const key = context.env('API_KEY')
  //    ^? string
})
```

When defining a middleware, you can declare env types that the middleware expects to use.

```typescript
import type { RequestContext } from 'alien-middleware'

// Assuming `Env` is defined like in the previous example.
const myMiddleware = (context: RequestContext<any, Env>) => {
  const key = context.env('API_KEY')
}
```

In both examples, we skip declaring any additional context properties (the first type parameter) because we're not using any. The second type parameter is for environment variables. The third is for the special `context.platform` property, whose value is provided by the host platform (e.g. Node.js, Deno, Bun, etc). On principle, a middleware should avoid using the `context.platform` property, since that could make it non-portable unless you write extra fallback logic for other hosts.
